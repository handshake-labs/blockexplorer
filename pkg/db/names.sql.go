// Code generated by sqlc. DO NOT EDIT.
// source: names.sql

package db

import (
	"context"

	"github.com/handshake-labs/blockexplorer/pkg/types"
)

const getNameBidsByHash = `-- name: GetNameBidsByHash :many
SELECT
  transactions.txid AS txid,
  COALESCE(blocks.height, -1)::integer AS block_height,
  COALESCE(lockups.value, -1)::integer AS lockup_value,
  COALESCE(reveals.value, -1)::integer AS reveal_value
FROM
  tx_outputs lockups
  INNER JOIN transactions ON (lockups.txid = transactions.txid)
  LEFT JOIN blocks ON (transactions.block_hash = blocks.hash)
  LEFT JOIN tx_outputs reveals ON (reveals.covenant_action = 'REVEAL' AND lockups.covenant_name_hash = reveals.covenant_name_hash AND lockups.address = reveals.address)
  LEFT JOIN tx_inputs ON (reveals.txid = tx_inputs.txid AND lockups.index = tx_inputs.index)
WHERE lockups.covenant_action = 'BID' AND lockups.covenant_name_hash = $1::bytea
ORDER BY (blocks.height, transactions.index, lockups.index) DESC NULLS FIRST
LIMIT $3::integer OFFSET $2::integer
`

type GetNameBidsByHashParams struct {
	NameHash types.Bytes
	Offset   int32
	Limit    int32
}

type GetNameBidsByHashRow struct {
	Txid        types.Bytes
	BlockHeight int32
	LockupValue int32
	RevealValue int32
}

func (q *Queries) GetNameBidsByHash(ctx context.Context, arg GetNameBidsByHashParams) ([]GetNameBidsByHashRow, error) {
	rows, err := q.db.QueryContext(ctx, getNameBidsByHash, arg.NameHash, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNameBidsByHashRow{}
	for rows.Next() {
		var i GetNameBidsByHashRow
		if err := rows.Scan(
			&i.Txid,
			&i.BlockHeight,
			&i.LockupValue,
			&i.RevealValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNameCountsByHash = `-- name: GetNameCountsByHash :one
SELECT
  (COUNT(*) FILTER (WHERE covenant_action = 'BID'))::integer AS bids_count,
  COUNT(covenant_record_data)::integer AS records_count
FROM tx_outputs
WHERE covenant_name_hash = $1::bytea
`

type GetNameCountsByHashRow struct {
	BidsCount    int32
	RecordsCount int32
}

func (q *Queries) GetNameCountsByHash(ctx context.Context, nameHash types.Bytes) (GetNameCountsByHashRow, error) {
	row := q.db.QueryRowContext(ctx, getNameCountsByHash, nameHash)
	var i GetNameCountsByHashRow
	err := row.Scan(&i.BidsCount, &i.RecordsCount)
	return i, err
}

const getNameRecordsByHash = `-- name: GetNameRecordsByHash :many
SELECT
  transactions.txid AS txid,
  COALESCE(blocks.height, -1)::integer AS block_height,
  tx_outputs.covenant_record_data::bytea AS data
FROM
  tx_outputs
  INNER JOIN transactions ON (tx_outputs.txid = transactions.txid)
  LEFT JOIN blocks ON (transactions.block_hash = blocks.hash)
WHERE tx_outputs.covenant_record_data IS NOT NULL AND tx_outputs.covenant_name_hash = $1::bytea
ORDER BY (blocks.height, transactions.index, tx_outputs.index) DESC NULLS FIRST
LIMIT $3::integer OFFSET $2::integer
`

type GetNameRecordsByHashParams struct {
	NameHash types.Bytes
	Offset   int32
	Limit    int32
}

type GetNameRecordsByHashRow struct {
	Txid        types.Bytes
	BlockHeight int32
	Data        types.Bytes
}

func (q *Queries) GetNameRecordsByHash(ctx context.Context, arg GetNameRecordsByHashParams) ([]GetNameRecordsByHashRow, error) {
	rows, err := q.db.QueryContext(ctx, getNameRecordsByHash, arg.NameHash, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNameRecordsByHashRow{}
	for rows.Next() {
		var i GetNameRecordsByHashRow
		if err := rows.Scan(&i.Txid, &i.BlockHeight, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservedName = `-- name: GetReservedName :one
SELECT origin_name, name, name_hash, claim_amount
FROM reserved_names
WHERE name = $1
`

func (q *Queries) GetReservedName(ctx context.Context, name string) (ReservedName, error) {
	row := q.db.QueryRowContext(ctx, getReservedName, name)
	var i ReservedName
	err := row.Scan(
		&i.OriginName,
		&i.Name,
		&i.NameHash,
		&i.ClaimAmount,
	)
	return i, err
}
