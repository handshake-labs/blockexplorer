// Code generated by sqlc. DO NOT EDIT.
// source: names.sql

package db

import (
	"context"

	"github.com/handshake-labs/blockexplorer/pkg/types"
)

const getLastNameBlockHeightByActionAndHash = `-- name: GetLastNameBlockHeightByActionAndHash :one
SELECT
  COALESCE(blocks.height, -1)::integer AS block_height_not_null
FROM
  tx_outputs
  INNER JOIN transactions ON (tx_outputs.txid = transactions.txid)
  LEFT JOIN blocks ON (transactions.block_hash = blocks.hash)
WHERE covenant_action = $1 AND covenant_name_hash = $2
ORDER BY blocks.height DESC NULLS FIRST
LIMIT 1
`

type GetLastNameBlockHeightByActionAndHashParams struct {
	CovenantAction   CovenantAction
	CovenantNameHash *types.Bytes
}

func (q *Queries) GetLastNameBlockHeightByActionAndHash(ctx context.Context, arg GetLastNameBlockHeightByActionAndHashParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLastNameBlockHeightByActionAndHash, arg.CovenantAction, arg.CovenantNameHash)
	var block_height_not_null int32
	err := row.Scan(&block_height_not_null)
	return block_height_not_null, err
}

const getNameBidsByHash = `-- name: GetNameBidsByHash :many
SELECT
  transactions.txid AS txid,
  COALESCE(blocks.height, -1)::integer AS block_height_not_null,
  lockups.value AS lockup_value,
  COALESCE(reveals.value, -1)::bigint AS reveal_value_not_null
FROM
  tx_outputs lockups
  INNER JOIN transactions ON (lockups.txid = transactions.txid)
  LEFT JOIN blocks ON (transactions.block_hash = blocks.hash)
  LEFT JOIN tx_outputs reveals ON (reveals.covenant_action = 'REVEAL' AND lockups.covenant_name_hash = reveals.covenant_name_hash AND lockups.address = reveals.address)
  LEFT JOIN tx_inputs ON (reveals.txid = tx_inputs.txid AND lockups.index = tx_inputs.index)
WHERE lockups.covenant_action = 'BID' AND lockups.covenant_name_hash = $1::bytea
ORDER BY (blocks.height, transactions.index, lockups.index) DESC NULLS FIRST
LIMIT $3::integer OFFSET $2::integer
`

type GetNameBidsByHashParams struct {
	NameHash types.Bytes
	Offset   int32
	Limit    int32
}

type GetNameBidsByHashRow struct {
	Txid               types.Bytes
	BlockHeightNotNull int32
	LockupValue        int64
	RevealValueNotNull int64
}

func (q *Queries) GetNameBidsByHash(ctx context.Context, arg GetNameBidsByHashParams) ([]GetNameBidsByHashRow, error) {
	rows, err := q.db.QueryContext(ctx, getNameBidsByHash, arg.NameHash, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNameBidsByHashRow{}
	for rows.Next() {
		var i GetNameBidsByHashRow
		if err := rows.Scan(
			&i.Txid,
			&i.BlockHeightNotNull,
			&i.LockupValue,
			&i.RevealValueNotNull,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNameCountsByHash = `-- name: GetNameCountsByHash :one
SELECT
  (COUNT(*) FILTER (WHERE covenant_action = 'BID'))::integer AS bids_count,
  COUNT(covenant_record_data)::integer AS records_count
FROM tx_outputs
WHERE covenant_name_hash = $1::bytea
`

type GetNameCountsByHashRow struct {
	BidsCount    int32
	RecordsCount int32
}

func (q *Queries) GetNameCountsByHash(ctx context.Context, nameHash types.Bytes) (GetNameCountsByHashRow, error) {
	row := q.db.QueryRowContext(ctx, getNameCountsByHash, nameHash)
	var i GetNameCountsByHashRow
	err := row.Scan(&i.BidsCount, &i.RecordsCount)
	return i, err
}

const getNameRecordsByHash = `-- name: GetNameRecordsByHash :many
SELECT
  transactions.txid AS txid,
  COALESCE(blocks.height, -1)::integer AS block_height_not_null,
  tx_outputs.covenant_record_data::bytea AS data
FROM
  tx_outputs
  INNER JOIN transactions ON (tx_outputs.txid = transactions.txid)
  LEFT JOIN blocks ON (transactions.block_hash = blocks.hash)
WHERE tx_outputs.covenant_record_data IS NOT NULL AND tx_outputs.covenant_name_hash = $1::bytea
ORDER BY (blocks.height, transactions.index, tx_outputs.index) DESC NULLS FIRST
LIMIT $3::integer OFFSET $2::integer
`

type GetNameRecordsByHashParams struct {
	NameHash types.Bytes
	Offset   int32
	Limit    int32
}

type GetNameRecordsByHashRow struct {
	Txid               types.Bytes
	BlockHeightNotNull int32
	Data               types.Bytes
}

func (q *Queries) GetNameRecordsByHash(ctx context.Context, arg GetNameRecordsByHashParams) ([]GetNameRecordsByHashRow, error) {
	rows, err := q.db.QueryContext(ctx, getNameRecordsByHash, arg.NameHash, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNameRecordsByHashRow{}
	for rows.Next() {
		var i GetNameRecordsByHashRow
		if err := rows.Scan(&i.Txid, &i.BlockHeightNotNull, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservedName = `-- name: GetReservedName :one
SELECT 
CONVERT_FROM(origin_name, 'SQL_ASCII')::text as origin_name,
CONVERT_FROM(name, 'SQL_ASCII')::text as name,
name_hash,
claim_amount
FROM reserved_names
WHERE name = $1
`

type GetReservedNameRow struct {
	OriginName  string
	Name        string
	NameHash    types.Bytes
	ClaimAmount int64
}

func (q *Queries) GetReservedName(ctx context.Context, name string) (GetReservedNameRow, error) {
	row := q.db.QueryRowContext(ctx, getReservedName, name)
	var i GetReservedNameRow
	err := row.Scan(
		&i.OriginName,
		&i.Name,
		&i.NameHash,
		&i.ClaimAmount,
	)
	return i, err
}
