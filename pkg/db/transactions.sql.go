// Code generated by sqlc. DO NOT EDIT.
// source: transactions.sql

package db

import (
	"context"

	"github.com/handshake-labs/blockexplorer/pkg/types"
)

const getTransactionByTxid = `-- name: GetTransactionByTxid :one
SELECT
    txid, witness_tx, fee, rate, block_hash, index, version, locktime, size
FROM
    transactions
WHERE
    txid = $1
`

func (q *Queries) GetTransactionByTxid(ctx context.Context, txid types.Bytes) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByTxid, txid)
	var i Transaction
	err := row.Scan(
		&i.Txid,
		&i.WitnessTx,
		&i.Fee,
		&i.Rate,
		&i.BlockHash,
		&i.Index,
		&i.Version,
		&i.Locktime,
		&i.Size,
	)
	return i, err
}

const getTransactionsByBlockHash = `-- name: GetTransactionsByBlockHash :many
SELECT txid, witness_tx, fee, rate, block_hash, index, version, locktime, size, (COUNT(*) OVER())::smallint as count
FROM transactions
WHERE block_hash = $1::bytea
ORDER BY index
LIMIT $3::smallint OFFSET $2::smallint
`

type GetTransactionsByBlockHashParams struct {
	BlockHash types.Bytes
	Offset    int16
	Limit     int16
}

type GetTransactionsByBlockHashRow struct {
	Txid      types.Bytes
	WitnessTx types.Bytes
	Fee       int64
	Rate      int64
	BlockHash types.Bytes
	Index     int32
	Version   int32
	Locktime  int32
	Size      int64
	Count     int16
}

func (q *Queries) GetTransactionsByBlockHash(ctx context.Context, arg GetTransactionsByBlockHashParams) ([]GetTransactionsByBlockHashRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBlockHash, arg.BlockHash, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByBlockHashRow{}
	for rows.Next() {
		var i GetTransactionsByBlockHashRow
		if err := rows.Scan(
			&i.Txid,
			&i.WitnessTx,
			&i.Fee,
			&i.Rate,
			&i.BlockHash,
			&i.Index,
			&i.Version,
			&i.Locktime,
			&i.Size,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTransaction = `-- name: InsertTransaction :exec
INSERT INTO transactions (txid, witness_tx, fee, rate, block_hash, index, "version", locktime, "size")
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type InsertTransactionParams struct {
	Txid      types.Bytes
	WitnessTx types.Bytes
	Fee       int64
	Rate      int64
	BlockHash types.Bytes
	Index     int32
	Version   int32
	Locktime  int32
	Size      int64
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, insertTransaction,
		arg.Txid,
		arg.WitnessTx,
		arg.Fee,
		arg.Rate,
		arg.BlockHash,
		arg.Index,
		arg.Version,
		arg.Locktime,
		arg.Size,
	)
	return err
}
