// Code generated by sqlc. DO NOT EDIT.
// source: transactions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/handshake-labs/blockexplorer/pkg/types"
)

const getMempoolTransactions = `-- name: GetMempoolTransactions :many
SELECT txid, witness_tx, fee, rate, block_hash, index, version, locktime, size
FROM transactions
WHERE block_hash IS NULL 
ORDER BY index
LIMIT $1 OFFSET $2
`

type GetMempoolTransactionsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetMempoolTransactions(ctx context.Context, arg GetMempoolTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getMempoolTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Txid,
			&i.WitnessTx,
			&i.Fee,
			&i.Rate,
			&i.BlockHash,
			&i.Index,
			&i.Version,
			&i.Locktime,
			&i.Size,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByTxid = `-- name: GetTransactionByTxid :one
SELECT transactions.txid, transactions.witness_tx, transactions.fee, transactions.rate, transactions.block_hash, transactions.index, transactions.version, transactions.locktime, transactions.size, COALESCE(blocks.height, -1) FROM transactions LEFT OUTER JOIN blocks ON transactions.block_hash=blocks.hash WHERE transactions.txid = $1
`

type GetTransactionByTxidRow struct {
	Txid      types.Bytes
	WitnessTx types.Bytes
	Fee       int64
	Rate      int64
	BlockHash *types.Bytes
	Index     sql.NullInt32
	Version   int32
	Locktime  int32
	Size      int64
	Height    int32
}

func (q *Queries) GetTransactionByTxid(ctx context.Context, txid types.Bytes) (GetTransactionByTxidRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByTxid, txid)
	var i GetTransactionByTxidRow
	err := row.Scan(
		&i.Txid,
		&i.WitnessTx,
		&i.Fee,
		&i.Rate,
		&i.BlockHash,
		&i.Index,
		&i.Version,
		&i.Locktime,
		&i.Size,
		&i.Height,
	)
	return i, err
}

const getTransactionsByBlockHash = `-- name: GetTransactionsByBlockHash :many
SELECT txid, witness_tx, fee, rate, block_hash, index, version, locktime, size
FROM transactions
WHERE block_hash = $1
ORDER BY index
LIMIT $2 OFFSET $3
`

type GetTransactionsByBlockHashParams struct {
	BlockHash *types.Bytes
	Limit     int32
	Offset    int32
}

func (q *Queries) GetTransactionsByBlockHash(ctx context.Context, arg GetTransactionsByBlockHashParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBlockHash, arg.BlockHash, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Txid,
			&i.WitnessTx,
			&i.Fee,
			&i.Rate,
			&i.BlockHash,
			&i.Index,
			&i.Version,
			&i.Locktime,
			&i.Size,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTransaction = `-- name: InsertTransaction :exec
INSERT INTO transactions (txid, witness_tx, fee, rate, block_hash, index, "version", locktime, "size")
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type InsertTransactionParams struct {
	Txid      types.Bytes
	WitnessTx types.Bytes
	Fee       int64
	Rate      int64
	BlockHash *types.Bytes
	Index     sql.NullInt32
	Version   int32
	Locktime  int32
	Size      int64
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, insertTransaction,
		arg.Txid,
		arg.WitnessTx,
		arg.Fee,
		arg.Rate,
		arg.BlockHash,
		arg.Index,
		arg.Version,
		arg.Locktime,
		arg.Size,
	)
	return err
}
